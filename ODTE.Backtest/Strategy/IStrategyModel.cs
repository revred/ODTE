using ODTE.Backtest.Config;
using ODTE.Backtest.Data;
using ODTE.Contracts.Data;
using ODTE.Contracts.Historical;

namespace ODTE.Backtest.Strategy;

/// <summary>
/// Interface for all trading strategy models that can be loaded dynamically
/// WHY: Enables unified backtesting of different models (SPX30DTE, PM414, OILY212, etc.)
/// through configuration rather than hard-coded backtester classes
/// </summary>
public interface IStrategyModel
{
    /// <summary>
    /// Unique identifier for this strategy model (e.g., "SPX30DTE", "PM414")
    /// </summary>
    string ModelName { get; }

    /// <summary>
    /// Model version for traceability (e.g., "v1.0", "v2.1")
    /// </summary>
    string ModelVersion { get; }

    /// <summary>
    /// Initialize the strategy with configuration and data providers
    /// Called once at backtest start
    /// </summary>
    Task InitializeAsync(SimConfig config, IMarketData marketData, IOptionsData optionsData);

    /// <summary>
    /// Generate trading signals for a specific market timestamp
    /// Returns list of candidate orders or empty list if no trades
    /// </summary>
    Task<List<CandidateOrder>> GenerateSignalsAsync(
        DateTime timestamp,
        MarketDataBar currentBar,
        PortfolioState portfolio);

    /// <summary>
    /// Handle position management and exits
    /// Called for each timestamp to manage existing positions
    /// </summary>
    Task<List<CandidateOrder>> ManagePositionsAsync(
        DateTime timestamp,
        MarketDataBar currentBar,
        PortfolioState portfolio);

    /// <summary>
    /// Get model-specific configuration parameters
    /// Used for traceability and reporting
    /// </summary>
    Dictionary<string, object> GetModelParameters();

    /// <summary>
    /// Validate that this model can run with the current configuration
    /// Throws exception if configuration is incompatible
    /// </summary>
    void ValidateConfiguration(SimConfig config);

    /// <summary>
    /// Clean up resources when backtest completes
    /// </summary>
    void Dispose();
}

/// <summary>
/// Candidate order generated by strategy models
/// </summary>
public class CandidateOrder
{
    public string OrderId { get; set; } = string.Empty;
    public string Symbol { get; set; } = string.Empty;
    public string StrategyType { get; set; } = string.Empty; // "BWB", "PROBE", "HEDGE"
    public OrderType OrderType { get; set; }
    public List<OrderLeg> Legs { get; set; } = new();
    public decimal ExpectedCredit { get; set; }
    public decimal MaxRisk { get; set; }
    public string EntryReason { get; set; } = string.Empty;
    public DateTime ExpirationDate { get; set; }
    public Dictionary<string, object> Metadata { get; set; } = new();
}

/// <summary>
/// Individual leg of a multi-leg options strategy
/// </summary>
public class OrderLeg
{
    public string Symbol { get; set; } = string.Empty;
    public decimal Strike { get; set; }
    public DateTime Expiration { get; set; }
    public OptionType OptionType { get; set; } // Call/Put
    public int Quantity { get; set; } // Positive = buy, negative = sell
    public decimal ExpectedPrice { get; set; }
}

/// <summary>
/// Order types supported by the execution engine
/// </summary>
public enum OrderType
{
    Market,
    Limit,
    Spread,
    Stop,
    StopLimit
}

/// <summary>
/// Option type enumeration
/// </summary>
public enum OptionType
{
    Call,
    Put
}

/// <summary>
/// Current portfolio state passed to strategy models
/// </summary>
public class PortfolioState
{
    public decimal AccountValue { get; set; }
    public decimal AvailableBuyingPower { get; set; }
    public decimal UnrealizedPnL { get; set; }
    public decimal RealizedPnL { get; set; }
    public List<Position> OpenPositions { get; set; } = new();
    public Dictionary<string, decimal> Greeks { get; set; } = new();
    public Dictionary<string, decimal> RiskMetrics { get; set; } = new();
}

/// <summary>
/// Individual position in the portfolio
/// </summary>
public class Position
{
    public string PositionId { get; set; } = string.Empty;
    public string Symbol { get; set; } = string.Empty;
    public string StrategyType { get; set; } = string.Empty;
    public DateTime EntryDate { get; set; }
    public DateTime ExpirationDate { get; set; }
    public List<PositionLeg> Legs { get; set; } = new();
    public decimal UnrealizedPnL { get; set; }
    public decimal MaxRisk { get; set; }
    public Dictionary<string, object> Metadata { get; set; } = new();
}

/// <summary>
/// Individual leg of a position
/// </summary>
public class PositionLeg
{
    public string Symbol { get; set; } = string.Empty;
    public decimal Strike { get; set; }
    public DateTime Expiration { get; set; }
    public OptionType OptionType { get; set; }
    public int Quantity { get; set; }
    public decimal EntryPrice { get; set; }
    public decimal CurrentPrice { get; set; }
}